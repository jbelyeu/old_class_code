/*
0-Quit
1-Encrypt text using the Caesar Cipher and a key
2-Decrypt text using the Caesar Cipher and a key
3-Decrypt text using the Caesar Cipher without the key
4-Encrypt text using the "Super Cipher" and a key
5-Decrypt text using the "Super Cipher" and a key
6-Decrypt text using the "Super Cipher" without the key
1
Enter text to encrypt.
This is a very clever test!
Please enter key.4
88      108     109     119     36      109     119     36      101     36
122     105     118     34      36      103     112     105     122     105
118     36      120     105     119     120     37      Xlmw$mw$e$ziv"$gpiziv$xi
wx%
0-Quit
1-Encrypt text using the Caesar Cipher and a key
2-Decrypt text using the Caesar Cipher and a key
3-Decrypt text using the Caesar Cipher without the key
4-Encrypt text using the "Super Cipher" and a key
5-Decrypt text using the "Super Cipher" and a key
6-Decrypt text using the "Super Cipher" without the key
2
Enter text to decrypt.
Xlmw$mw$e$ziv"$gpiziv$xiwx%
Please enter key.4
This is a very clever test!
0-Quit
1-Encrypt text using the Caesar Cipher and a key
2-Decrypt text using the Caesar Cipher and a key
3-Decrypt text using the Caesar Cipher without the key
4-Encrypt text using the "Super Cipher" and a key
5-Decrypt text using the "Super Cipher" and a key
6-Decrypt text using the "Super Cipher" without the key
0
Press any key to continue . . .*/

/*
0-Quit
1-Encrypt text using the Caesar Cipher and a key
2-Decrypt text using the Caesar Cipher and a key
3-Decrypt text using the Caesar Cipher without the key
4-Encrypt text using the "Super Cipher" and a key
5-Decrypt text using the "Super Cipher" and a key
6-Decrypt text using the "Super Cipher" without the key
3
Enter text to decrypt.
#$Xlmw$mw$e$ziv"$gpiziv$xiwx%
#  which is ASCII 35 occurs 1 times.
$  which is ASCII 36 occurs 6 times.
X  which is ASCII 88 occurs 1 times.
l  which is ASCII 108 occurs 1 times.
m  which is ASCII 109 occurs 2 times.
w  which is ASCII 119 occurs 3 times.
e  which is ASCII 101 occurs 1 times.
z  which is ASCII 122 occurs 2 times.
i  which is ASCII 105 occurs 4 times.
v  which is ASCII 118 occurs 2 times.
"  which is ASCII 34 occurs 1 times.
g  which is ASCII 103 occurs 1 times.
p  which is ASCII 112 occurs 1 times.
x  which is ASCII 120 occurs 2 times.
%  which is ASCII 37 occurs 1 times.
The most repeated character is $ which is repeated 6 time(s).
The key may be 4 and message may be:
z This is a very clever test!
The second most repeated character is i which is repeated 4time(s).
The key may be 73 and the message may be
56j#$.6$.6w61 -46y' 1 -6/ ./7
0-Quit
1-Encrypt text using the Caesar Cipher and a key
2-Decrypt text using the Caesar Cipher and a key
3-Decrypt text using the Caesar Cipher without the key
4-Encrypt text using the "Super Cipher" and a key
5-Decrypt text using the "Super Cipher" and a key
6-Decrypt text using the "Super Cipher" without the key
0
Press any key to continue . . .
*/
/*
0-Quit
1-Encrypt text using the Caesar Cipher and a key
2-Decrypt text using the Caesar Cipher and a key
3-Decrypt text using the Caesar Cipher without the key
4-Encrypt text using the "Super Cipher" and a key
5-Decrypt text using the "Super Cipher" and a key
6-Decrypt text using the "Super Cipher" without the key
4
Enter text to encrypt.
this is a very clever test.
Please enter the 4 part key.1
2
3
4
117     106     108     119     33      107     118     36      98      34
121     105     115     32      35      103     109     103     121     105
115     34      119     105     116     118     49      ujlw!kv$b"yis #gmgyis"wi
tv1
0-Quit
1-Encrypt text using the Caesar Cipher and a key
2-Decrypt text using the Caesar Cipher and a key
3-Decrypt text using the Caesar Cipher without the key
4-Encrypt text using the "Super Cipher" and a key
5-Decrypt text using the "Super Cipher" and a key
6-Decrypt text using the "Super Cipher" without the key
0
Press any key to continue . . .*/
/*
0-Quit
1-Encrypt text using the Caesar Cipher and a key
2-Decrypt text using the Caesar Cipher and a key
3-Decrypt text using the Caesar Cipher without the key
4-Encrypt text using the "Super Cipher" and a key
5-Decrypt text using the "Super Cipher" and a key
6-Decrypt text using the "Super Cipher" without the key
4
Enter text to encrypt.
This is a very clever test!
Please enter the 4 part key.1
2
3
4
85      106     108     119     33      107     118     36      98      34
121     105     115     32      35      103     109     103     121     105
115     34      119     105     116     118     36      Ujlw!kv$b"yis #gmgyis"wi
tv$
0-Quit
1-Encrypt text using the Caesar Cipher and a key
2-Decrypt text using the Caesar Cipher and a key
3-Decrypt text using the Caesar Cipher without the key
4-Encrypt text using the "Super Cipher" and a key
5-Decrypt text using the "Super Cipher" and a key
6-Decrypt text using the "Super Cipher" without the key
5
Enter text to decrypt.
Ujlw!kv$b"yis #gmgyis"witv$
Please enter the 4 part key.1
2
3
4
84      104     105     115     32      105     115     32      97      32
118     101     114     121     32      99      108     101     118     101
114     32      116     101     115     116     33      This is a very clever te
st!
0-Quit
1-Encrypt text using the Caesar Cipher and a key
2-Decrypt text using the Caesar Cipher and a key
3-Decrypt text using the Caesar Cipher without the key
4-Encrypt text using the "Super Cipher" and a key
5-Decrypt text using the "Super Cipher" and a key
6-Decrypt text using the "Super Cipher" without the key
0
Press any key to continue . . .*/

/*
0-Quit
1-Encrypt text using the Caesar Cipher and a key
2-Decrypt text using the Caesar Cipher and a key
3-Decrypt text using the Caesar Cipher without the key
4-Encrypt text using the "Super Cipher" and a key
5-Decrypt text using the "Super Cipher" and a key
6-Decrypt text using the "Super Cipher" without the key
6
Enter text to decrypt.
Ujlw!kv$b"yis #gmgyis"witv$
U  which is ASCII 85 occurs 1 times.
!  which is ASCII 33 occurs 1 times.
b  which is ASCII 98 occurs 1 times.
s  which is ASCII 115 occurs 2 times.
m  which is ASCII 109 occurs 1 times.
t  which is ASCII 116 occurs 1 times.
The most repeated character is s which is repeated 2 time(s).
U  which is ASCII 85 occurs 1 times.
!  which is ASCII 33 occurs 1 times.
b  which is ASCII 98 occurs 1 times.
s  which is ASCII 115 occurs 2 times.
m  which is ASCII 109 occurs 1 times.
t  which is ASCII 116 occurs 1 times.
j  which is ASCII 106 occurs 1 times.
k  which is ASCII 107 occurs 1 times.
"  which is ASCII 34 occurs 2 times.
   which is ASCII 32 occurs 1 times.
g  which is ASCII 103 occurs 1 times.
v  which is ASCII 118 occurs 1 times.
The most repeated character is " which is repeated 2 time(s).
U  which is ASCII 85 occurs 1 times.
!  which is ASCII 33 occurs 1 times.
b  which is ASCII 98 occurs 1 times.
s  which is ASCII 115 occurs 2 times.
m  which is ASCII 109 occurs 1 times.
t  which is ASCII 116 occurs 1 times.
j  which is ASCII 106 occurs 1 times.
k  which is ASCII 107 occurs 1 times.
"  which is ASCII 34 occurs 2 times.
   which is ASCII 32 occurs 1 times.
g  which is ASCII 103 occurs 1 times.
v  which is ASCII 118 occurs 1 times.
l  which is ASCII 108 occurs 1 times.
y  which is ASCII 121 occurs 2 times.
#  which is ASCII 35 occurs 1 times.
w  which is ASCII 119 occurs 1 times.
$  which is ASCII 36 occurs 1 times.
The most repeated character is y which is repeated 2 time(s).
U  which is ASCII 85 occurs 1 times.
!  which is ASCII 33 occurs 1 times.
b  which is ASCII 98 occurs 1 times.
s  which is ASCII 115 occurs 2 times.
m  which is ASCII 109 occurs 1 times.
t  which is ASCII 116 occurs 1 times.
j  which is ASCII 106 occurs 1 times.
k  which is ASCII 107 occurs 1 times.
"  which is ASCII 34 occurs 2 times.
   which is ASCII 32 occurs 1 times.
g  which is ASCII 103 occurs 1 times.
v  which is ASCII 118 occurs 1 times.
l  which is ASCII 108 occurs 1 times.
y  which is ASCII 121 occurs 2 times.
#  which is ASCII 35 occurs 1 times.
w  which is ASCII 119 occurs 1 times.
$  which is ASCII 36 occurs 1 times.
i  which is ASCII 105 occurs 3 times.
The most repeated character is i which is repeated 3 time(s).
The key is 83, 2, 89,73 and message is:
]hn.)ix6j    y%yue    y !t&
0-Quit
1-Encrypt text using the Caesar Cipher and a key
2-Decrypt text using the Caesar Cipher and a key
3-Decrypt text using the Caesar Cipher without the key
4-Encrypt text using the "Super Cipher" and a key
5-Decrypt text using the "Super Cipher" and a key
6-Decrypt text using the "Super Cipher" without the key
0
Press any key to continue . . .

*/

#include <iostream>
#include <vector>
#include <string>
#include <cstdlib>
#include <cstring>


using namespace std;

//Asks for string, convert to vector of integers
vector<int> string_to_int(vector<int> values, string text)
{
	for (int i = 0; i < text.size(); i++)
	{
	values.push_back(text[i]);
	}
	return values;

}
vector<int> wrapper(vector<int> values)
{
	const int upper_lim = 122; //upper limit of codable range
	const int wrap = 91; //value to decrement and return to correct range
	for (int i = 0; i< values.size(); i++)
	{
		if (values[i] > upper_lim)
		{
			values[i] -= wrap; //decrement to wrap back around and attain desired symbol value
		}
	}
	return values;
}

//receives vector of integers, cipher key. Encrypts vector using key.
vector<int> en_caesar_cipher(vector<int> values, int caesar_key)
{
	for (int i = 0; i < values.size(); i++)
	{
		values[i] = (values[i] + caesar_key);

	}
	values = wrapper(values);

	
	return values;
}

vector<char> int_to_char(vector<int> values, vector<char> characters)
{
	for (int i = 0; i < values.size(); i++)
	{
		characters.push_back(values[i]);
	}
	return characters;
}
vector<int> unwrapper(vector<int> values)
{
	const int lower_lim = 32; //lower limit of codable range
	const int wrap = 91; //value to decrement and return to correct range

	for (int i = 0; i < values.size(); i++)
	{ 
		if (values[i] < lower_lim)
		{
			values[i] += wrap; //increment to wrap back around and attain desired symbol value
		}
	}
	return values;
}

//receives vector of integers, cipher key. Decrypts vector using key.
vector<int> de_caesar_cipher(vector<int> values, int caesar_key)
{

	for (int i = 0; i < values.size(); i++)
	{
		values[i] = (values[i] - caesar_key);
	}

	values = unwrapper(values);
	return values;
}

void freq_check(vector<int>& count_up, vector<char>& keep_track, string text)
{
	int counter = 0;
	for (int i = 0; i < text.size(); i++)
	{
		
		int nuther = text[i];
		for (int j = 0; j < text.size(); j++)
		{
			if (nuther == text[j])
			{
				counter++;
			}

		}
		//the_counters.push_back(counter);
		bool myBool = true;
		for (int h = 0; h < keep_track.size(); h++)
		{
			if ( keep_track[h] == nuther)
			{
				keep_track[h] = nuther;
				myBool = false;
			}
		}
		if (myBool)
		{
			keep_track.push_back(nuther);
			count_up.push_back(counter);
		}			
		counter =0;
	}
	for (int i = 0; i < keep_track.size(); i++)
	{
		vector<char> shortterm;
		char temp = keep_track[i];
		for (int j = 0; j < keep_track.size(); j++)
		{
			if (keep_track[j] !=temp)
			{
				shortterm.push_back(keep_track[j]);
			}
		}
	}	
}
void super_freq_check(vector<int>& count_up, vector<char>& keep_track, vector<char> start_at_element)
{
	int counter = 0;
	for (int i = 0; i < start_at_element.size(); i++)
	{
		
		int nuther = start_at_element[i];
		for (int j = 0; j < start_at_element.size(); j++)
		{
			if (nuther == start_at_element[j])
			{
				counter++;
			}

		}
		//the_counters.push_back(counter);
		bool myBool = true;
		for (int h = 0; h < keep_track.size(); h++)
		{
			if ( keep_track[h] == nuther)
			{
				keep_track[h] = nuther;
				myBool = false;
			}
		}
		if (myBool)
		{
			keep_track.push_back(nuther);
			count_up.push_back(counter);
		}			
		counter =0;
	}
	for (int i = 0; i < keep_track.size(); i++)
	{
		vector<char> shortterm;
		char temp = keep_track[i];
		for (int j = 0; j < keep_track.size(); j++)
		{
			if (keep_track[j] !=temp)
			{
				shortterm.push_back(keep_track[j]);
			}
		}
	}	
}

int first_frequency(vector<int>& count_up, vector<char>& keep_track)
{
	int most_freq = 0; //used to record the element number of the overall most repeated character
	int checker = count_up[0]; //used to compare each element to the rest in size.
	
	for (int i = 0; i < count_up.size(); i++)
	{
		if (count_up[i] < checker)
		{
		}
		else 
		{
			checker = count_up[i];
			most_freq = i;
		}
	}
	
	return most_freq;
}

int second_frequency (vector<int>& count_up, vector<char>& keep_track, int most_freq) //finds second most repeated character
{
	int sec_most_freq = 0; //used to record the element number of the second most repeated character
	int checker = count_up[0]; //used to compare each element to the rest in size.
	
	for (int i = 0; i < count_up.size(); i++)
	{
		if (count_up[i] < checker)
		{
		}
		else if (i != most_freq)
		{
			checker = count_up[i];
			sec_most_freq = i;
		}
	}
	
	return sec_most_freq;
}
int find_key (vector<char>& keep_track, int possible_key)
{
	const int space = 32; //ASCII value of blank space
	int ascii_value = keep_track[possible_key];
	int key = (ascii_value - space);
	return key;
}

vector<int> en_multiple_cipher(vector<int> values, vector<int> super_key)
{
	int j = 0;
	for (int i = 0; i <values.size(); i +=4)
	{
		values[i] += super_key[j];
	}
	j++;
	for (int i = 1; i <values.size(); i +=4)
	{
		values[i] += super_key[j];
	}
	j++;
	for (int i = 2; i <values.size(); i +=4)
	{
		values[i] += super_key[j];
	}
	j++;
	for (int i = 3; i <values.size(); i +=4)
	{
		values[i] += super_key[j];
	}
	return values;
}
vector<int> de_multiple_cipher(vector<int> values, vector<int> super_key)
{
	int j = 0;
	for (int i = 0; i <values.size(); i +=4)
	{
		values[i] -= super_key[j];
	}
	j++;
	for (int i = 1; i <values.size(); i +=4)
	{
		values[i] -= super_key[j];
	}
	j++;
	for (int i = 2; i <values.size(); i +=4)
	{
		values[i] -= super_key[j];
	}
	j++;
	for (int i = 3; i <values.size(); i +=4)
	{
		values[i] -= super_key[j];
	}
	return values;
}

void sort_super_cipher(string text, vector<char>& start_at_0, vector<char>& start_at_1, vector<char>& start_at_2, vector<char>& start_at_3)
{
	for (int i = 0; i < text.size(); i +=4)
	{
		start_at_0.push_back(text[i]);
	}
	for (int i = 1; i < text.size(); i +=4)
	{
		start_at_1.push_back(text[i]);
	}
	for (int i = 2; i < text.size(); i +=4)
	{
		start_at_2.push_back(text[i]);
	}
	for (int i = 3; i < text.size(); i +=4)
	{
		start_at_3.push_back(text[i]);
	}
}

vector<int> keyless_super_cipher(vector<int> values, int key_0, int key_1, int key_2, int key_3)
{
	const int wrap = 91; //value to increment to return to correct range

	for (int i = 0; i < values.size(); i += 4)
	{
		values[i] -= key_0;
	}
	for (int i = 1; i < values.size(); i += 4)
	{
		values[i] -= key_1;
	}
	for (int i = 2; i < values.size(); i += 4)
	{
		values[i]  -= key_2;
	}
	for (int i = 3; i < values.size(); i += 4)
	{
		values[i]-= key_3;
	}	
	values = unwrapper(values);
	return values;
}


int main()
{
	bool playball = true;
	vector<char> characters;
	vector<int> values;
	while (playball)
	{
	values.clear();
	characters.clear();
	cout << "0-Quit" <<endl;
	cout <<	"1-Encrypt text using the Caesar Cipher and a key" <<endl;
	cout << "2-Decrypt text using the Caesar Cipher and a key" <<endl;
	cout << "3-Decrypt text using the Caesar Cipher without the key" << endl;
	cout << "4-Encrypt text using the \"Super Cipher\" and a key" <<endl;
	cout << "5-Decrypt text using the \"Super Cipher\" and a key" << endl;
	cout << "6-Decrypt text using the \"Super Cipher\" without the key" << endl;
	int option;
	int caesar_key;
	string text;
	
	cin  >> option;
	cin.ignore();
	

	if (option == 0)
	{
		playball = false;
	}
	else if (option == 1)
	{
		//call function to ask for a string and define it, then convert it to integers.
		cout << "Enter text to encrypt." <<endl;
		
		getline(cin, text);

		values = string_to_int(values, text);
		
		cout << "Please enter key.";
		cin >> caesar_key;
		cin.ignore();
		
	
		values = en_caesar_cipher(values, caesar_key);
		for (int i = 0; i < values.size(); i ++)
		{
			cout << values[i] << "\t";
		}
		characters = int_to_char(values, characters);
		for (int i = 0; i < characters.size(); i ++)
		{
			cout << characters[i];
		}
		cout << endl;
		
	}
	else if (option == 2)
	{
		cout << "Enter text to decrypt." << endl;
		getline(cin, text);

		values = string_to_int(values, text);
		
		cout << "Please enter key.";
		cin >> caesar_key;
		cin.ignore();

		values = de_caesar_cipher(values, caesar_key);
		
		characters = int_to_char(values, characters);
		
		for (int i = 0; i < characters.size(); i ++)
		{
			cout << characters[i];
		}
		cout << endl;
				
	}
	else if (option == 3)
	{
		cout << "Enter text to decrypt." << endl;
		getline(cin, text);
		vector<int> count_up;
		vector<char> keep_track;
		freq_check(count_up, keep_track, text);

		for (int i=0; i < count_up.size(); i++)
		{
			cout << keep_track[i] << " ";
			int element = keep_track[i];
			cout <<" which is ASCII "<< element <<" occurs ";
			cout << count_up[i] << " times." <<endl;
		
		}
		int most_freq = first_frequency(count_up, keep_track);
		int second_most_freq = second_frequency(count_up, keep_track, most_freq);
			
		cout << "The most repeated character is " << keep_track[most_freq] << " which is repeated " <<count_up[most_freq] << " time(s). " << endl;
		
		int key = find_key(keep_track, most_freq);
		cout << "The key may be " << key << " and message may be: " << endl;

		values = string_to_int(values, text);
		values = de_caesar_cipher(values, key);
		characters = int_to_char(values, characters);
		
		for (int i = 0; i < characters.size(); i ++)
		{
			cout << characters[i];
		}
		cout << endl;

		values.clear();
		characters.clear();

		cout << "The second most repeated character is " << keep_track[second_most_freq] << " which is repeated " << count_up[second_most_freq] << "time(s)." <<endl;
		key = find_key(keep_track, second_most_freq);
		cout << "The key may be " << key << " and the message may be " <<endl; 

		values = string_to_int(values, text);
		values = de_caesar_cipher(values, key);
		characters = int_to_char(values, characters);

		for (int i = 0; i < characters.size(); i ++)
		{
			cout << characters[i];
		}
		cout << endl;
	}
	else if (option == 4)
	{
		cout << "Enter text to encrypt. " << endl;		
		
		getline(cin, text);

		values = string_to_int(values, text);
		int temp_key = 0;
		const int key_size = 4;
		
		cout << "Please enter the 4 part key.";
		vector<int> super_key(key_size);

		for (int i = 0; i < key_size; i++)
		{
			cin >> super_key[i];
		}
		cin.ignore();
		values = en_multiple_cipher(values, super_key);	
		
		values = wrapper(values);
		for (int i = 0; i < values.size(); i ++)
		{
			cout << values[i] << "\t";
		}

		characters = int_to_char(values, characters);
		for (int i = 0; i < characters.size(); i ++)
		{
			cout << characters[i];
		}
		cout << endl;
	}
	else if (option == 5)
	{
		cout << "Enter text to decrypt. " << endl;		
		
		getline(cin, text);

		values = string_to_int(values, text);
		int temp_key = 0;
		const int key_size = 4;
		
		cout << "Please enter the 4 part key.";
		vector<int> super_key(key_size);

		for (int i = 0; i < key_size; i++)
		{
			cin >> super_key[i];
		}
		cin.ignore();
		values = de_multiple_cipher(values, super_key);	
		
		values = unwrapper(values);
		for (int i = 0; i < values.size(); i ++)
		{
			cout << values[i] << "\t";
		}

		characters = int_to_char(values, characters);
		for (int i = 0; i < characters.size(); i ++)
		{
			cout << characters[i];
		}
		cout << endl;
	}
	else if (option == 6)
	{
	cout << "Enter text to decrypt." << endl;
		getline(cin, text);
		vector<char> start_at_0;
		vector<char> start_at_1;
		vector<char> start_at_2;
		vector<char> start_at_3;
		vector<int> count_up;
		vector<char> keep_track;

		sort_super_cipher(text, start_at_0, start_at_1, start_at_2, start_at_3);		
		
		
		super_freq_check(count_up, keep_track, start_at_0);

		for (int i=0; i < count_up.size(); i++)
		{
			cout << keep_track[i] << " ";
			int element = keep_track[i];
			cout <<" which is ASCII "<< element <<" occurs ";
			cout << count_up[i] << " times." <<endl;		
		}
		int most_freq = first_frequency(count_up, keep_track);
		cout << "The most repeated character is " << keep_track[most_freq] << " which is repeated " <<count_up[most_freq] << " time(s). " << endl;
		int key_0 = find_key(keep_track, most_freq);

		super_freq_check(count_up, keep_track, start_at_1);

		for (int i=0; i < count_up.size(); i++)
		{
			cout << keep_track[i] << " ";
			int element = keep_track[i];
			cout <<" which is ASCII "<< element <<" occurs ";
			cout << count_up[i] << " times." <<endl;		
		}
		most_freq = first_frequency(count_up, keep_track);
		cout << "The most repeated character is " << keep_track[most_freq] << " which is repeated " <<count_up[most_freq] << " time(s). " << endl;
		int key_1 = find_key(keep_track, most_freq);

		super_freq_check(count_up, keep_track, start_at_2);

		for (int i=0; i < count_up.size(); i++)
		{
			cout << keep_track[i] << " ";
			int element = keep_track[i];
			cout <<" which is ASCII "<< element <<" occurs ";
			cout << count_up[i] << " times." <<endl;		
		}
		most_freq = first_frequency(count_up, keep_track);
		cout << "The most repeated character is " << keep_track[most_freq] << " which is repeated " <<count_up[most_freq] << " time(s). " << endl;
		int key_2 = find_key(keep_track, most_freq);

		super_freq_check(count_up, keep_track, start_at_3);

		for (int i=0; i < count_up.size(); i++)
		{
			cout << keep_track[i] << " ";
			int element = keep_track[i];
			cout <<" which is ASCII "<< element <<" occurs ";
			cout << count_up[i] << " times." <<endl;		
		}

		most_freq = first_frequency(count_up, keep_track);
		cout << "The most repeated character is " << keep_track[most_freq] << " which is repeated " <<count_up[most_freq] << " time(s). " << endl;
		int key_3 = find_key(keep_track, most_freq);		
		
		cout << "The key is " << key_0 << ", "<<key_1 << ", " << key_2 << "," << key_3 << " and message is: " << endl;

		values = string_to_int(values, text);

		values = keyless_super_cipher(values, key_0, key_1 , key_2, key_3);
		characters = int_to_char(values, characters);
		
		for (int i = 0; i < characters.size(); i ++)
		{
			cout << characters[i];
		}
		cout << endl;

		values.clear();
		characters.clear();

	}
	else 
	{
	cout << "Invalid option. Please try again" <<endl;
	}
	values.clear();
	
	}	
	system ("pause");
	return 0;
}